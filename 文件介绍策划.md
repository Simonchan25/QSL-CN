第一阶段要的效果是 我输入股票名 然后自动分析基本面 技术面 新闻 宏观 然后llm(本地ollama)帮我分析和总结  然后数据全部来自tushare

# QStockLAB A股 MVP（TuShare + 本地 Ollama）

MVP 目标：**输入股票名 → （仅 TuShare）抓数 → 基本面/技术面/公告/宏观 → LLM（Ollama）结构化总结 + 建议 → 前端显示**。

---

## 目录结构（建议）

```
qstocklab_a_mvp/
├── backend/
│   ├── app.py                 # FastAPI 主入口（/analyze）
│   ├── requirements.txt       # 后端依赖
│   ├── .env.example           # 环境变量样例
│   ├── core/
│   │   ├── tushare_client.py  # TuShare 封装（限速、重试、缓存）
│   │   ├── indicators.py      # 技术指标计算（RSI/MACD/BOLL）
│   │   ├── fundamentals.py    # 基本面抓取与整理
│   │   ├── macro.py           # 宏观数据抓取与快照
|   |   |── news.py         # 新闻抓取
│   │   └── analyze.py         # 汇总 pipeline（拼包 + 规则信号）
│   └── nlp/
│       └── ollama_client.py   # 本地 Ollama 调用与提示词
└── frontend/
    ├── package.json
    ├── src/
    │   └── App.jsx            # 单页界面：输入股票名 → 展示结果
    └── index.html
```

> 说明：前后端都尽量**单文件可跑**。后期再模块化/增强。

---

## 后端依赖（backend/requirements.txt）

```
fastapi==0.111.0
uvicorn==0.30.0
python-dotenv==1.0.1
pydantic==2.7.1
pandas==2.2.2
numpy==1.26.4
requests==2.32.3
cachetools==5.3.3
# TuShare
lxml==5.2.2
tushare==1.2.89
```

---

## 环境变量样例（backend/.env.example）

```
TUSHARE_TOKEN=替换为你的TuShare令牌
OLLAMA_URL=http://localhost:11434
OLLAMA_MODEL=deepseek-r1:32b
SERVER_HOST=0.0.0.0
SERVER_PORT=8000
```

---

## FastAPI 主入口（backend/app.py）

```python
import os
import uvicorn
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from dotenv import load_dotenv

from core.analyze import run_pipeline, resolve_by_name

load_dotenv()

app = FastAPI(title="QStockLAB A股 MVP")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class AnalyzeRequest(BaseModel):
    name: str

@app.get("/health")
def health():
    return {"ok": True}

@app.get("/resolve")
def resolve(name: str):
    item = resolve_by_name(name)
    if not item:
        raise HTTPException(404, detail=f"未找到包含“{name}”的A股")
    return item

@app.post("/analyze")
def analyze(req: AnalyzeRequest):
    if not req.name:
        raise HTTPException(400, detail="name 不能为空")
    try:
        result = run_pipeline(req.name)
        return result
    except Exception as e:
        raise HTTPException(500, detail=str(e))

if __name__ == "__main__":
    host = os.getenv("SERVER_HOST", "0.0.0.0")
    port = int(os.getenv("SERVER_PORT", 8000))
    uvicorn.run(app, host=host, port=port)
```

---

## TuShare 封装（backend/core/tushare\_client.py）

```python
import os
import time
import functools
from typing import Optional

import pandas as pd
import tushare as ts
from cachetools import TTLCache

_TUSHARE_TOKEN = os.getenv("TUSHARE_TOKEN")
if not _TUSHARE_TOKEN:
    raise RuntimeError("缺少环境变量 TUSHARE_TOKEN")

_pro = ts.pro_api(_TUSHARE_TOKEN)
_cache = TTLCache(maxsize=256, ttl=60*10)  # 10分钟内简单缓存

# 简单限速（TuShare 通常 120/min）
_last_call_ts = 0.0
_MIN_INTERVAL = 0.6  # ~100/min

def _rate_limit():
    global _last_call_ts
    now = time.time()
    wait = _MIN_INTERVAL - (now - _last_call_ts)
    if wait > 0:
        time.sleep(wait)
    _last_call_ts = time.time()


def cached(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        key = (func.__name__, tuple(args), tuple(sorted(kwargs.items())))
        if key in _cache:
            return _cache[key]
        out = func(*args, **kwargs)
        _cache[key] = out
        return out
    return wrapper

@cached
def stock_basic() -> pd.DataFrame:
    _rate_limit()
    df = _pro.stock_basic(fields="ts_code,symbol,name,area,industry,market,list_status,fullname")
    return df or pd.DataFrame()

@cached
def daily(ts_code: str, start_date: str, end_date: str) -> pd.DataFrame:
    _rate_limit()
    df = _pro.daily(ts_code=ts_code, start_date=start_date, end_date=end_date)
    return df or pd.DataFrame()

@cached
def fina_indicator(ts_code: str) -> pd.DataFrame:
    _rate_limit()
    return _pro.fina_indicator(ts_code=ts_code) or pd.DataFrame()

@cached
def income(ts_code: str, limit: int = 8) -> pd.DataFrame:
    _rate_limit()
    return _pro.income(ts_code=ts_code, limit=limit) or pd.DataFrame()

@cached
def balancesheet(ts_code: str, limit: int = 4) -> pd.DataFrame:
    _rate_limit()
    return _pro.balancesheet(ts_code=ts_code, limit=limit) or pd.DataFrame()

@cached
def cashflow(ts_code: str, limit: int = 4) -> pd.DataFrame:
    _rate_limit()
    return _pro.cashflow(ts_code=ts_code, limit=limit) or pd.DataFrame()

@cached
def anns(ts_code: str, limit: int = 15) -> pd.DataFrame:
    _rate_limit()
    return _pro.anns(ts_code=ts_code, limit=limit) or pd.DataFrame()

@cached
def cpi():
    _rate_limit()
    return _pro.cpi() or pd.DataFrame()

@cached
def ppi():
    _rate_limit()
    return _pro.ppi() or pd.DataFrame()

@cached
def money_supply():
    _rate_limit()
    return _pro.money_supply() or pd.DataFrame()

@cached
def shibor():
    _rate_limit()
    return _pro.shibor() or pd.DataFrame()
```

---

## 技术指标（backend/core/indicators.py）

```python
import pandas as pd
import numpy as np

def compute_indicators(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty:
        return df
    df = df.sort_values("trade_date").reset_index(drop=True)
    px = df["close"].astype(float).values

    # RSI(14)
    period = 14
    delta = np.diff(px, prepend=px[0])
    up = np.where(delta > 0, delta, 0.0)
    down = np.where(delta < 0, -delta, 0.0)
    roll_up = pd.Series(up).rolling(period).mean()
    roll_down = pd.Series(down).rolling(period).mean()
    rs = roll_up / (roll_down + 1e-9)
    rsi = 100.0 - (100.0 / (1.0 + rs))

    # MACD(12,26,9)
    ema12 = pd.Series(px).ewm(span=12, adjust=False).mean()
    ema26 = pd.Series(px).ewm(span=26, adjust=False).mean()
    dif = ema12 - ema26
    dea = dif.ewm(span=9, adjust=False).mean()
    macd = (dif - dea) * 2

    # BOLL(20,2)
    ma20 = pd.Series(px).rolling(20).mean()
    std20 = pd.Series(px).rolling(20).std(ddof=0)
    upper = ma20 + 2 * std20
    lower = ma20 - 2 * std20

    df["rsi14"] = rsi.values
    df["dif"] = dif.values
    df["dea"] = dea.values
    df["macd"] = macd.values
    df["ma20"] = ma20.values
    df["boll_up"] = upper.values
    df["boll_dn"] = lower.values
    return df


def build_tech_signal(row: pd.Series) -> str:
    sig = []
    rsi = row.get("rsi14")
    if pd.notna(rsi):
        if rsi < 30: sig.append("RSI<30（超卖）")
        elif rsi > 70: sig.append("RSI>70（超买）")
    dif, dea = row.get("dif"), row.get("dea")
    if pd.notna(dif) and pd.notna(dea):
        if dif > dea: sig.append("DIF>DEA（偏多）")
        elif dif < dea: sig.append("DIF<DEA（偏空）")
    close, up, dn = row.get("close"), row.get("boll_up"), row.get("boll_dn")
    if pd.notna(close) and pd.notna(up) and pd.notna(dn):
        if close >= up: sig.append("收盘>=上轨（强势/风险）")
        elif close <= dn: sig.append("收盘<=下轨（弱势/反弹）")
    return "；".join(sig) if sig else "无明显信号"
```

---

## 基本面/公告/宏观（backend/core/fundamentals.py, macro.py）

```python
# backend/core/fundamentals.py
from typing import Dict, Any, List
import pandas as pd
from .tushare_client import fina_indicator, income, balancesheet, cashflow


def fetch_fundamentals(ts_code: str) -> Dict[str, Any]:
    out: Dict[str, Any] = {}

    fi = fina_indicator(ts_code)
    if not fi.empty:
        fi = fi.sort_values("end_date", ascending=False).reset_index(drop=True)
        latest = fi.iloc[0].to_dict()
        keep = [
            "end_date","roe","roa","grossprofit_margin","netprofit_margin",
            "asset_turn","op_yoy","or_yoy","profit_dedt","q_dtprofit","q_profit_yoy","q_gr_yoy"
        ]
        out["fina_indicator_latest"] = {k: latest.get(k) for k in keep}

    inc = income(ts_code, limit=8)
    if not inc.empty:
        inc = inc.sort_values("end_date", ascending=False)
        cols = ["end_date","revenue","n_income","n_income_attr_p","total_profit","operate_profit"]
        out["income_recent"] = inc[cols].head(6).to_dict(orient="records")

    bal = balancesheet(ts_code, limit=4)
    if not bal.empty:
        bal = bal.sort_values("end_date", ascending=False)
        rows: List[Dict[str, Any]] = []
        for _, r in bal.iterrows():
            ta = r.get("total_assets")
            tl = r.get("total_liab")
            lev = float(tl)/float(ta) if pd.notna(ta) and pd.notna(tl) and float(ta)!=0 else None
            rows.append({
                "end_date": r.get("end_date"),
                "total_assets": ta,
                "total_liab": tl,
                "debt_ratio": lev,
            })
        out["balance_recent"] = rows

    cf = cashflow(ts_code, limit=4)
    if not cf.empty:
        cf = cf.sort_values("end_date", ascending=False)
        rows: List[Dict[str, Any]] = []
        for _, r in cf.iterrows():
            cfo = r.get("n_cashflow_act")
            capex = r.get("procure_fixed_assets")
            fcf = float(cfo) - float(capex) if pd.notna(cfo) and pd.notna(capex) else None
            rows.append({
                "end_date": r.get("end_date"),
                "n_cashflow_act": cfo,
                "procure_fixed_assets": capex,
                "rough_fcf": fcf,
            })
        out["cashflow_recent"] = rows

    return out
```

```python
# backend/core/macro.py
from typing import Dict, Any
from .tushare_client import cpi, ppi, money_supply, shibor


def fetch_macro_snapshot() -> Dict[str, Any]:
    out: Dict[str, Any] = {}

    _cpi = cpi()
    if not _cpi.empty:
        _cpi = _cpi.sort_values("month", ascending=False).reset_index(drop=True)
        out["cpi_latest"] = _cpi.iloc[0][["month","cpi"]].to_dict()

    _ppi = ppi()
    if not _ppi.empty:
        _ppi = _ppi.sort_values("month", ascending=False).reset_index(drop=True)
        out["ppi_latest"] = _ppi.iloc[0][["month","ppi_yoy"]].to_dict()

    _ms = money_supply()
    if not _ms.empty:
        _ms = _ms.sort_values("month", ascending=False).reset_index(drop=True)
        out["m2_latest"] = _ms.iloc[0][["month","m2_yoy"]].to_dict()

    _shb = shibor()
    if not _shb.empty:
        _shb = _shb.sort_values("date", ascending=False).reset_index(drop=True)
        out["shibor_latest"] = _shb.iloc[0][["date","on","1w"]].to_dict()

    return out
```

---

## LLM（Ollama）客户端（backend/nlp/ollama\_client.py）

```python
import os
import json
import requests

OLLAMA_URL = os.getenv("OLLAMA_URL", "http://localhost:11434")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "deepseek-r1:32b")

SYS_PROMPT = (
    "你是A股投研助理。只基于提供的TuShare数据，输出六段："
    "【公司概况】【基本面】【技术面】【公告/新闻】【宏观与风险】【结论与建议】。"
    "限制：不预测价格，不给出肯定的买卖指令；数据缺失要明确标注，不编造。"
)

def summarize(chunks: dict) -> str:
    body = {
        "model": OLLAMA_MODEL,
        "prompt": SYS_PROMPT + "\n\n" + json.dumps(chunks, ensure_ascii=False, indent=2),
        "stream": False,
        "options": {"temperature": 0.2, "num_ctx": 8192},
    }
    try:
        r = requests.post(f"{OLLAMA_URL}/api/generate", json=body, timeout=120)
        r.raise_for_status()
        return r.json().get("response", "").strip()
    except Exception as e:
        return f"[LLM错误] {e}"
```

---

## 分析 Pipeline（backend/core/analyze.py）

```python
import datetime as dt
from typing import Optional, Dict, Any
import pandas as pd

from .tushare_client import stock_basic, daily, anns
from .indicators import compute_indicators, build_tech_signal
from .fundamentals import fetch_fundamentals
from .macro import fetch_macro_snapshot
from ..nlp.ollama_client import summarize

PRICE_YEARS = 2
MAX_NEWS = 15


def _date_str(days_ago: int) -> str:
    d = dt.date.today() - dt.timedelta(days=days_ago)
    return d.strftime("%Y%m%d")


def resolve_by_name(name_keyword: str) -> Optional[dict]:
    base = stock_basic()
    hit = base[base["name"].str.contains(name_keyword, case=False, regex=False, na=False)]
    if hit.empty:
        hit = base[base["fullname"].str.contains(name_keyword, case=False, regex=False, na=False)]
        if hit.empty:
            return None
    hit = hit.copy()
    hit["rank"] = 0
    hit.loc[hit["list_status"] != "L", "rank"] += 100
    hit.loc[hit["market"].str.contains("北交", na=False), "rank"] += 10
    hit["rank"] += (hit["name"].str.len() - len(name_keyword)).abs().fillna(9)
    hit = hit.sort_values(["rank","market","ts_code"]).reset_index(drop=True)
    return hit.iloc[0].to_dict()


def run_pipeline(name_keyword: str) -> Dict[str, Any]:
    # 1) 解析标的
    base = resolve_by_name(name_keyword)
    if not base:
        raise ValueError(f"未找到包含“{name_keyword}”的A股")
    ts_code = base["ts_code"]

    # 2) 技术面
    end = _date_str(0)
    start = (dt.date.today() - dt.timedelta(days=365*PRICE_YEARS+30)).strftime("%Y%m%d")
    px = daily(ts_code, start, end)
    tech = {}
    if not px.empty:
        px = px.sort_values("trade_date").reset_index(drop=True)
        px = compute_indicators(px)
        last = px.iloc[-1]
        tech = {
            "tech_last_close": float(last.get("close")) if pd.notna(last.get("close")) else None,
            "tech_last_rsi": round(float(last.get("rsi14")),2) if pd.notna(last.get("rsi14")) else None,
            "tech_last_macd": round(float(last.get("macd")),4) if pd.notna(last.get("macd")) else None,
            "tech_last_dif": round(float(last.get("dif")),4) if pd.notna(last.get("dif")) else None,
            "tech_last_dea": round(float(last.get("dea")),4) if pd.notna(last.get("dea")) else None,
            "tech_signal": build_tech_signal(last),
        }

    # 3) 基本面
    fundamental = fetch_fundamentals(ts_code)

    # 4) 公告
    news_df = anns(ts_code, limit=MAX_NEWS)
    news_list = []
    if not news_df.empty:
        news_df = news_df.sort_values("ann_date", ascending=False).head(MAX_NEWS)
        for _, r in news_df.iterrows():
            news_list.append({"ann_date": r.get("ann_date"), "title": r.get("title"), "seq": r.get("ann_id") or r.get("seq")})

    # 5) 宏观
    macro = fetch_macro_snapshot()

    # 6) 组包 → LLM
    chunks = {
        "basic": base,
        "fundamental": fundamental,
        "news": news_list,
        "macro": macro,
        **tech,
    }
    llm_summary = summarize({
        "股票基本信息": base,
        "基本面摘要": fundamental,
        "技术面末日": tech,
        "公告列表": news_list,
        "宏观快照": macro,
    })

    return {
        "basic": base,
        "technical": tech,
        "fundamental": fundamental,
        "news": news_list,
        "macro": macro,
        "llm_summary": llm_summary,
    }
```

---

## 前端（最简单页）

**frontend/package.json**（Vite + React）

```json
{
  "name": "qsl-a-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "vite": "^5.3.4"
  }
}
```

**frontend/index.html**

```html
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QStockLAB A股 MVP</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/App.jsx"></script>
  </body>
</html>
```

**frontend/src/App.jsx**（单文件组件，调用 /analyze）

```jsx
import { useState } from 'react'

export default function App() {
  const [name, setName] = useState('贵州茅台')
  const [loading, setLoading] = useState(false)
  const [data, setData] = useState(null)
  const [error, setError] = useState('')

  const analyze = async () => {
    setError(''); setLoading(true); setData(null)
    try {
      const res = await fetch('http://localhost:8000/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      })
      if (!res.ok) throw new Error(await res.text())
      const j = await res.json()
      setData(j)
    } catch (e) {
      setError(String(e))
    } finally {
      setLoading(false)
    }
  }

  return (
    <div style={{ maxWidth: 900, margin: '40px auto', fontFamily: 'system-ui, -apple-system' }}>
      <h1>QStockLAB A股 MVP</h1>
      <p>输入股票名称关键字（仅使用 TuShare 数据 + 本地 Ollama 总结）</p>
      <div style={{ display: 'flex', gap: 12 }}>
        <input value={name} onChange={e=>setName(e.target.value)} style={{ flex: 1, padding: 8 }} placeholder="如：宁德时代" />
        <button onClick={analyze} disabled={loading} style={{ padding: '8px 16px' }}>{loading ? '分析中…' : '分析'}</button>
      </div>

      {error && <pre style={{ color: 'crimson', whiteSpace: 'pre-wrap' }}>{error}</pre>}

      {data && (
        <div style={{ marginTop: 24 }}>
          <section>
            <h3>基本信息</h3>
            <pre style={{ whiteSpace:'pre-wrap' }}>{JSON.stringify(data.basic, null, 2)}</pre>
          </section>
          <section>
            <h3>技术面（末日）</h3>
            <pre style={{ whiteSpace:'pre-wrap' }}>{JSON.stringify(data.technical, null, 2)}</pre>
          </section>
          <section>
            <h3>基本面</h3>
            <pre style={{ whiteSpace:'pre-wrap' }}>{JSON.stringify(data.fundamental, null, 2)}</pre>
          </section>
          <section>
            <h3>公告（近条）</h3>
            <pre style={{ whiteSpace:'pre-wrap' }}>{JSON.stringify(data.news, null, 2)}</pre>
          </section>
          <section>
            <h3>宏观快照</h3>
            <pre style={{ whiteSpace:'pre-wrap' }}>{JSON.stringify(data.macro, null, 2)}</pre>
          </section>
          <section>
            <h3>LLM 总结</h3>
            <div style={{ border:'1px solid #ddd', padding: 12, borderRadius: 8, background:'#fafafa' }}>
              {data.llm_summary}
            </div>
          </section>
        </div>
      )}
    </div>
  )
}
```

---

## 启动步骤

**后端**

```bash
cd backend
cp .env.example .env  # 填入 TUSHARE_TOKEN 等
python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
python app.py
# 访问 http://localhost:8000/health
```

**前端**

```bash
cd frontend
npm i
npm run dev
# 打开 http://localhost:5173
```

---

## 后续可加的“建议/评分”模块（规则版，非投资建议）

* 在 `core/analyze.py` 里新增 `scorecard`：

  * 基本面分：ROE / 净利率 / 负债率 / 近四期营收净利趋势 → 0–60
  * 技术面分：RSI、MACD 金叉/死叉、BOLL 位置 → 0–30
  * 宏观权重：M2 同比、Shibor 变化 → −10～+10
  * 结论用 LLM 语言化（“仅供研究，不构成建议”）。

这样你能在 **第一阶段** 就完成“输入股票名 → 一键出研报式总结与提示”。
